<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

	<head>
		<meta charset="utf-8">

		<title>FP with Java 8</title>

		<meta name="description" content="Functional programming with Java 8">
		<meta name="author" content="Mateusz Szczap">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h1>FP</h1>
                    <h3>with Java 8</h3>
    					<p>
                            <small>Mateusz Szczap</small><br>
                            <small>Email:&nbsp;<a href="emailto:mszczap@ebay.com">mszczap@ebay.com</a></small><br>
                            <small>Twitter:&nbsp;<a href="http://twitter.com/matiwinnetou">@matiwinnetou</a></small><br>
                            <small>mobile.de - eBay Inc. subsidiary</small><br>
                        </p>
                    <img height="20%" width="20%" src="Mobile.de-logo.jpg" />
				</section>

                <section>
                    <h2>What is it?</h2>
                    <blockquote>"At the heart of functional programming is thinking about your problem domain in terms of immutable values and functions that translate between them."</blockquote>
                </section>

                <section>
                    <h2>Advantages</h2><p>
                    <ul>
                        <li><blockquote>"Functional programming aims to let you more easily write programs that are concise, with fewer bugs and parallelizable."</blockquote></li>
                        <li><blockquote>"Using the Functional style allows code to be written that declares its intent clearly, without being mixed up with control flow statements(...)"</blockquote></li>
                        <li><blockquote>"Because of the principles like side-effect free programming [mutating state], it is much easier to reason about code, and check its correctness."</blockquote></li>
                    </ul>
                </section>

                <section>
                    <h2>Why? What for? Opinions..</h2><p>
                    <ul>
                        <li>WHAT instead of HOW? Declaratively communicates programmer's indent clearly</li>
                        <li>more concise code *IF NOT* abused increases code readability</li>
                        <li>easier to do parallel programming (immutable data structures, which are thread safe)</li>
                        <li>ability to write less error prone code</li>
                    </ul>
                </section>

                <section>
                    <h2>Sceptic's view</h2>
                    <blockquote>"There is of course nothing that is possible in functional but not imperative programming."</blockquote>
                </section>

                <section>
                    <blockquote>"The point of different programming paradigms isn't to make things possible that weren't possible before, it's to make things easy that were hard before."</blockquote>
                    <img src="elephant.gif" width="50%" height="50%"><br>
                    <a href="http://en.wikipedia.org/wiki/Blind_men_and_an_elephant">http://en.wikipedia.org/wiki/Blind_men_and_an_elephant</a>
                </section>

                <section>
                    <h2>Nothing comes for free...</h2>
                    <ul>
                        <li>investment into learning new paradigm (brain IOPs)</li>
                        <li>hard to understanding functional jargon (HOF, RT, Side-Effect Free, Monad, Monoid, Functor or Applicative Functor)?</li>
                        <li>FP is grounded in Category Theory and lots of people in FP use those academic terms</li>
                        <li>community is divided into practical programmers and academics followers of FP</li>
                    </ul>
                </section>

                <section>
                    <h2>Your Expectations - What I can deliver</h2><p>
                    <img src="fp_in_5_mins.jpg" width="30%" height="30%">
                    <blockquote>"Like OOP learning FP is more like a journey than something you can learn in 1-2 hours."</blockquote>
                </section>

                <section>
                    <h2>FP - declarative example</h2><p>
                    <pre><code>
final ImmutableList&lt;Person&gt; persons = ImmutableList.of(
    new Person("Patrick", Person.Gender.MALE, 170, 30),
    new Person("Stefan", Person.Gender.MALE , 180, 35),
    new Person("Julia", Person.Gender.FEMALE, 161, 25)
);

persons.stream()
    .filter(p -> p.getGender() == Person.Gender.MALE)
    .mapToDouble(p -> p.getHeight())
    .average()
    .ifPresent(average -> System.out.println(average));
--
175.0
                    </code></pre>
                </section>

                <section>
                    <h2>Imperative example</h2><p>
                    <pre><code>
final ImmutableList&lt;Person&gt; persons = ImmutableList.of(
  new Person("Patrick", Person.Gender.MALE, 170, 30),
  new Person("Stefan", Person.Gender.MALE, 180, 35),
  new Person("Julia", Person.Gender.FEMALE, 161, 25)
);

double sum = 0.0D;
for (Person p : persons) {
  if (p.gender == Person.MALE) {
   sum += p.getHeight();
  }
}

double avg = persons.size() == 0 ? 0: sum / persons.size();
System.out.println(avg);
                    </code></pre>
                </section>

                <section>
                    <h2>FP is *NOT* new but... unfamiliar, academic and alien?</h2>
                    <br>
                    <h2>Scheme</h2>
                    <pre><code>
(define (add-three number)
(+ number 3))

(define (add-three-to-each sent)
(every add-three sent))

> (add-three-to-each '(1 9 9 2))
(4 12 12 5)
                    </code></pre>
                </section>

                <section>
                    <h2>FP is *NOT* new</h2>
                    <p>Purely functional:</p>
                    <ul>
                        <li>Haskell</li>
                        <li>Lisp/Scheme</li>
                    </ul>
                    <p>OOP mixed with FP</p>
                    <ul>
                        <li>C#</li>
                        <li>F#</li>
                        <li>Java 8</li>
                        <li>Scala</li>
                    </ul>
                    <p>Java 8 is to C# what Scala is to F#.</p>
                </section>

                <section>
                    <h2>FP is Jargon's *Galore</h2>
                    <p>Esoteric nature of FP lies in cryptic language and jargon. Let's demystify some terms.</p>
                    <img src="h2.jpg" width="50%" height="50%">
                    <blockquote>*galore - (EN -> DE) - in Hülle und Fülle</blockquote>
                </section>

                <section>
                    <h2>Jargon's Galore - monomorphic function and polymorphic function</h2>
                    <ul>
                        <li><blockquote>"Monomorphic functions are functions that operate on one type of data only."</blockquote></li>
                        <li><blockquote>"Polymorphic functions are functions that work on any data type."</blockquote></li>
                    </ul>
                </section>

                <section>
                    <h2>Monomorphic functions</h2>
                    <pre>
                        <code>
private static ImmutableList&lt;Person&gt; people() {
    final Person p1 = new Person("Jan", Person.Gender.MALE, 172, 80, Optional.of(new Person.Address("Albert-Einstein", 1, 14345)));
    final Person p2 = new Person("Kathy", Person.Gender.FEMALE, 160, 16);

    return ImmutableList.of(p1, p2);
}

public Optional&lt;Person&gt; findAdult() {
    people().stream()
    .filter(p -> p.getAge() >= 18)
    .findFirst()
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Polymorphic functions</h2>
                    <pre>
                        <code>
private static ImmutableList&lt;Person&gt; people() {
    final Person p1 = new Person("Jan", Person.Gender.MALE, 172, 80, Optional.of(new Person.Address("Albert-Einstein", 1, 14345)));
    final Person p2 = new Person("Kathy", Person.Gender.FEMALE, 160, 16);

    return ImmutableList.of(p1, p2);
}

private static &lt;T&gt; Optional&lt;T&gt; findPoly() {
    return people().stream()
    .filter(isAdult())
    .map(e -> (T) e)
    .findAny();
}
                    </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Higher Order Function (HOF)</h2>
                    <blockquote>"In FP higher order function is a function that either takes a function as a parameter or outputs a function as a return value."</blockquote>
                </section>

                <section>
                    <h2>Jargon's Galore - HOF as an input</h2>
                    <img src="1_stone.jpg" width="10%" height="10%"><br>
                    <pre>
                        <code>
Function&lt;Double, String&gt; KG_TO_STONES = weight -> String.format("%f stones", weight * 0.157473);

static void printWeight(double weightInKg, Function&gt;Double, String&gt; scale) {
    System.out.println("Weight: " + scale.apply(weightInKg));
}

public static void main(String[] args) {
    printWeight(6.4D, KG_TO_STONES);
}
--
Weight: 1.007827 stones
                        </code>
                    </pre>
                    <blockquote>1 stone = 6.350 kg</blockquote>
                    <a href="http://en.wikipedia.org/wiki/Stone_%28unit%29">http://en.wikipedia.org/wiki/Stone_%28unit%29</a>
                </section>

                <section>
                    <h2>Jargon's Galore - HOF as an output</h2>
                    <pre>
                        <code>
@FunctionalInterface
public interface Predicate&lt;T&gt; {
    boolean test(T t);
}

Predicate&lt;Person&gt; isAdult() {
    return p -> p.getAge() >= 18;
}

final ImmutableList&lt;Person&gt; persons = ImmutableList.of(
    new Person("Patrick", Person.Gender.MALE, 170, 30),
    new Person("Stefan", Person.Gender.MALE , 180, 17),
    new Person("Julia", Person.Gender.FEMALE, 161, 25)
);

persons.stream()
    .filter(isAdult())
    .forEach(p -> System.out.printf("Adult person: %s:\n", p));
---
Adult person: Person{name='Patrick', height=170, gender=MALE, age=30}:
Adult person: Person{name='Julia', height=161, gender=FEMALE, age=25}:
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Function Application</h2>
                    <pre>
                        <code>
@Test
public void testAddOneFunction() {
    final Function&lt;Integer, Integer&gt; addOne = i -> i + 1;

    Assert.assertEquals(Integer.valueOf(3), addOne.apply(2));
}

@Test
public void testSquareFunction() {
    final Function&lt;Integer, Integer&gt; squareFun = i -> i * i;

    Assert.assertEquals(Integer.valueOf(4), squareFun.apply(2));
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Loan Pattern - 1</h2>
                    <pre>
                        <code>
public class Resource {

    public Resource() {
        System.out.println("Opening resource");
    }

    public void operate() {
        System.out.println("Operating on resource");
    }

    public void dispose() {
        System.out.println("Disposing resource");
    }
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Loan Pattern - 2</h2>
                    <pre>
                        <code>
final Resource resource = new Resource();
try {
    resource.operate();
} finally {
    resource.dispose();
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Loan Pattern - 3</h2>
                    <pre>
                        <code>
public static void withResource(Consumer&lt;Resource&gt; consumer) {
    Resource resource = new Resource();
        try {
            consumer.accept(resource);
        } finally {
            resource.dispose();
        }
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Function Composition - f(g(x))</h2>
                    <blockquote>"In mathematics, function composition is the pointwise application of one function to the result of another to produce a third function."</blockquote>
                    <blockquote>"The term "composition of functions" (or "composite function") refers
                        to the combining of functions in a manner where the output from one function
                        becomes the input for the next function."</blockquote>
                </section>

                <section>
                    <h2>Default Methods - Virtual Extension Methods</h2>
                    <blockquote>"Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces."</blockquote>
                    <pre>
                        <code>
List&lt;Person&gt; people = people();
people.forEach(p -> System.out.println(p));
                        </code>
                    </pre>
                    <p>Interfaces in Java can now implement methods. The benefit that default methods bring is that now it’s possible to add a new default method to the interface and it doesn’t break the implementations.</p>
                </section>

                <section>
                    <h2>Function Composition - compose</h2>
                    <pre>
                        <code>
java.util.function.Function&lt;T, R&gt;:
                            
default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {
    return (V v) -> apply(before.apply(v));
}
                        </code>
                    </pre>
                    <pre>
                        <code>
@Test
public void testComposed1() {
    final Function&lt;Integer, Integer&gt; addOne = i -> i + 1;
    final Function&lt;Integer, Integer&gt; square = i -> i * i;

    final Function&lt;Integer, Integer&gt; composed = square.compose(addOne);

    final List&lt;Integer&gt; ints = Lists.newArrayList(1, 2, 3, 4, 5).stream()
    .map(composed)
    .collect(Collectors.toList());

    Assert.assertEquals(Lists.newArrayList(4, 9, 16, 25, 36), ints);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Function Composition - andThen</h2>
                    <pre>
                        <code>
java.util.function.Function&lt;T, R&gt;:

default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
    return (T t) -> after.apply(apply(t));
}
                    </code>
                    </pre>
                    <pre>
                        <code>
@Test
public void testComposed2() {
    final Function&lt;Integer, Integer&gt; addOne = i -> i + 1;
    final Function&lt;Integer, Integer&gt; square = i -> i * i;

    final Function&lt;Integer, Integer&gt; composed = addOne.andThen(square);

    final List&lt;Integer&gt; ints = Lists.newArrayList(1, 2, 3, 4, 5).stream()
    .map(composed)
    .collect(Collectors.toList());

    Assert.assertEquals(Lists.newArrayList(4, 9, 16, 25, 36), ints);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Side Effect free programming</h2>
                    <blockquote>"In classical FP a side effect is a situation in which there is a mutation to a state.
                        Classical FP programming operates only on immutable data structures, instead of mutating state, FP programs yield a new state based on old state often using recursion."</blockquote>
                    <blockquote>"Procedure is often used to refer to a chunk of code with side-effects."</blockquote>
                </section>

                <section>
                    <h2>Side-Effect - lenient or strict</h2>
                    <ul>
                        <li>PRAGMATICS - lenient - local side effects acceptable</li>
                        <li>THEORISTS - strict - no side effects acceptable at all</li>
                    </ul>
                </section>

                <section>
                    <h2>Side-Effect - lenient example</h2>
                    <pre>
                        <code>
public ImmutableList&lt;Sys&gt; hitCountSys() {
    final ImmutableList.Builder&lt;Sys&gt; builder = ImmutableList.builder();
    builder.add(Timer.initial(metricRegistry));
    builder.add(new Normalizer());
    builder.add(new DefaultsProcessor());
    builder.add(new ApiMapper(geo));
    builder.add(new HitCountSearch(searchService));
    builder.add(new AsyncProcessor(ImmutableList.of()));
    builder.add(Timer.checkpoint("ecs.hitCount"));

    return builder.build();
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Side-Effect - strict example</h2>
                    <pre>
                        <code>
public OptionalDouble malesAverageHeight() {
    return people().stream()
    .filter(p -> p.getGender() == Person.Gender.MALE)
    .mapToDouble(p -> p.getHeight())
    .average();
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Memoization</h2>
                    <blockquote>"In computing, memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again."</blockquote>
                </section>

                <section>
                    <h2>Memoization</h2>
                    <pre>
                        <code>
public final class Memoizer&lt;T, U&gt; {

    private final Map&lt;T, U&gt; cache = new ConcurrentHashMap<>();

    private Memoizer() {}

    private Function&lt;T, U&gt; doMemoize(final Function&lt;T, U&gt; function) {
        return input -> cache.computeIfAbsent(input, function::apply);
    }

    public static &lt;T, U&gt; Function&lt;T, U&gt; memoize(final Function&lt;T, &gt; function) {
        return new Memoizer&lt;T, U&gt;().doMemoize(function);
    }

}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Memoization - example</h2>
                    <pre>
                        <code>
@Test
public void testMemoization() {
    Function&lt;Integer, Integer&gt; square = x -> x * x;
    Function&lt;Integer, Integer&gt; memoized = Memoizer.memoize(square);

    assertEquals(Integer.valueOf(100), square.apply(10));

    assertEquals(Integer.valueOf(100), memoized.apply(10));
    assertEquals(Integer.valueOf(100), memoized.apply(10));
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Memoization - caveats</h2>
                    <blockquote>"There is a kind of function that may pose a problem: recursive functions that call themselves several times with the same argument may not be memoized this way."</blockquote>
                </section>

                <section>
                    <h2>Streams - generate</h2>
                    <blockquote>"A continuous flow of data."</blockquote>
                    <pre>
                        <code>
@Test
public void testGenerateSequenceOnes() {
    final List&lt;Integer&gt; ints = Stream.generate(() -> 1)
        .limit(10)
        .collect(Collectors.toList());

    Assert.assertEquals(Lists.newArrayList(1,1,1,1,1,1,1,1,1,1), ints);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Streams - iterate</h2>
                    <pre>
                        <code>
@Test
public void testGenerateSequenceInc() {
    final List&lt;Integer&gt; ints = Stream.iterate(0, i -> i + 1)
    .limit(10)
    .collect(Collectors.toList());

    Assert.assertEquals(Lists.newArrayList(0,1,2,3,4,5,6,7,8,9), ints);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Streams - concat</h2>
                    <pre>
                        <code>
@Test
public void testConcat() {
    final Stream&lt;Integer&gt; r1 = Stream.of(1, 2, 3);
    final Stream&lt;Integer&gt; r2 = Stream.of(3, 4, 5);

    final List&lt;Integer&gt; collect = Stream.concat(r1, r2)
        .distinct()
        .sorted(Comparator.reverseOrder())
        .collect(Collectors.toList());

    Assert.assertEquals(ImmutableList.of(5, 4, 3, 2, 1), collect);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Currying</h2>
                </section>

                <section>
                    <h2>Jargon's Galore - Persistent Collections</h2>
                </section>

                <section>
                    <h2>Jargon's Galore - Folds/Reductions</h2>
                    <blockquote>In spirit of side-effect free programming a lot of traditional computations with loops mutating state can be achieved using "reductions/folds".</blockquote>
                </section>

                <section>
                    <h2>Jargon's Galore - Folds/Reductions</h2>
                    <pre>
                        <code>
private static ImmutableList&lt;Person&gt; people() {
    final Person p1 = new Person("Jan", Person.Gender.MALE, 172, 80, Optional.of(new Person.Address("Albert-Einstein", 1, 14345)));
    final Person p2 = new Person("Kathy", Person.Gender.FEMALE, 160, 16);

    return ImmutableList.of(p1, p2);
}

final Integer totalAge = people().values().stream()
    .map(Person::getAge) // p -> p.getAge()
    .reduce(0, (age1, age2) -> age1 + age2);
--
96
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Monoid</h2>
                    <blockquote>"A monoid is an algebraic structure with a single associative binary operation and an identity element."</blockquote>
                </section>

                <section>
                    <h2>Monoid Example - Part 1</h2>
                    <pre>
                        <code>
public interface Monoid&lt;T&gt; {

    T zero(); //identity element

    BinaryOperator&lt;T&gt; operation(); //associative binary operation

}
                        </code>
                    </pre>
                    <pre>
                        <code>
public class StringMonoid implements Monoid&lt;String&gt; {

    public static final StringMonoid INSTANCE = new StringMonoid();

    public String zero() {
        return "";
    }

    public BinaryOperator&lt;String&gt; operation() {
        return (prev, next) -> prev + next;
    }

}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Monoid Example - Part 2</h2>
                    <pre>
                        <code>
private static ImmutableList&lt;Person&gt; people() {
    final Person p1 = new Person("Jan", Person.Gender.MALE, 172, 80, Optional.of(new Person.Address("Albert-Einstein", 1, 14345)));
    final Person p2 = new Person("Kathy", Person.Gender.FEMALE, 160, 16);

    return ImmutableList.of(p1, p2);
}

@Test
public void testStringMonoid() {
    final String reduced = people().stream()
      .map(p -> p.getName())
      .reduce(StringMonoid.INSTANCE.zero(), StringMonoid.INSTANCE.operation());

    assertEquals("JanKathy", reduced);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Functor (functional objects)</h2>
                    <blockquote>"By analogy to OOP - functor is an object with a function defined, very similar to strategy pattern."</blockquote>
                    <pre>
                        <code>
public interface Functor&lt;A,B extends Functor&lt;?,?&gt;&gt; {
    B map(Function&lt;A,B&gt; fun);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Jargon's Galore - Monad</h2>
                    <ul>
                        <li>Monads are container types</li>
                        <li>Monads Support Higher Order Functions</li>
                        <li>Monads are Combinable</li>
                        <li>Monads Can Be Built In Different Ways</li>
                    </ul>
                    <br>
                    <br>
                    <a href="http://james-iry.blogspot.de/2007/09/monads-are-elephants-part-1.html">http://james-iry.blogspot.de/2007/09/monads-are-elephants-part-1.html</a>
                </section>

                <section>
                    <h2>Monad by example</h2>
                    <pre>
                        <code>
public interface Monad&lt;A,B extends Monad&lt;?,?&gt;&gt; extends Functor&lt;A,B&gt; {
    B flatMap(Function&lt;A,B&gt; fun);
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Monad by example - Maybe</h2>
                    <pre>
                        <code>
public class Maybe&lt;A&gt; implements Monad&lt;A,Maybe&lt;?&gt;&gt; {

    private final A a;

    private Maybe(A a) {
        this.a = a;
    }

    public &lt;B&gt; Maybe&lt;B&gt; map(Function&lt;A,B&gt; fun) {
       return a == null ? return nothing() : just(fun.apply(a))
    }

    public &lt;B&gt; Maybe&lt;B&gt; flatMap(Function&lt;,Maybe&lt;?&gt;&gt; fun) {
        if (a == null) return nothing();
        else return (Maybe&lt;B&gt;)fun.apply(a);
    }

    public static &lt;A&gt; Maybe&lt;A&gt; just(A a) {
        return new Maybe&lt;A&gt;(a);
    }

    public static &lt;A&gt; Maybe&lt;A&gt; nothing() {
        return new Maybe&lt;&gt;(null);
    }

}
                        </code>
                    </pre>
                </section>

                <section>
                    <h2>Monad - Optional</h2>
                </section>

                <section>
                    <h2>Monad - known monads</h2>
                    <ul>
                        <li>Java8 - Optional&lt;T&gt;</li>
                        <li>Java8 - Stream&lt;T&gt;</li>
                        <li>RxJava - Observable&lt;T&gt;</li>
                        <li>Play - F.Promise&lt;T&gt;</li>
                    </ul>
                </section>

                <section>
                    <h2>Functional Operators - Part 1</h2>
                    <ul>
                        <li>zip - brings together two values</li>
                        <li>concat - brings together two values, usually one after another, good example: RxJava - Observable</li>
                        <li>map - transforms one value into another (one type to another)</li>
                        <li>flatMap - transforms one value into another and flattens it, e.g. avoids Optional&lt;Optional&lt;T&gt;&gt;</li>
                        <li>foldLeft - folds starting from the left</li>
                        <li>foldRight - folds starting from the right</li>
                        <li>reduceLeft - reduces from left</li>
                        <li>reduceRight - reduces from right</li>
                    </ul>
                    <br>
                    <blockquote>"Fold takes an explicit initial value for the accumulator while reduce uses the first element of the input list as the initial accumulator value."</blockquote>
                </section>

                <section>
                    <h2>Functional Operators - Part 2</h2>
                    <ul>
                        <li>sequence</li>
                        <li>findAny</li>
                        <li>findFirst</li>
                        <li>forEach</li>
                        <li>min</li>
                        <li>max</li>
                        <li>forAll</li>
                        <li>exists</li>
                        <li>dropWhile</li>
                        <li>takeWhile</li>
                        <li>distinct</li>
                        <li>limit</li>
                    </ul>
                </section>

                <section>
                    <h2>What is Java 8 missing</h2>
                    <ul>
                        <li>ADT - Algebraic Data Types</li>
                        <li>Pattern Matching</li>
                        <li>(lifting) - lifting method to function</li>
                        <li>Tail recursion</li>
                        <li>value types - case classes</li>
                        <li>standard functional methods like zip, takeWhile, etc, try [JOOL] - https://github.com/jOOQ/jOOL</li>
                        <li>limited monads in standard library</li>
                    </ul>
                </section>
                

                <!-- FP is not new - has been for years - scheme, Haskell, etc -->
                <!-- Only recently more popular as blended with OOP, e.g. OCaml, C#, F#, Scala -->

                <!-- "If you're talking about computability, there is of course nothing that is possible in functional but not imperative programming (or vice versa)." -->

                <!-- demystifying jargon vocabulary -->

                <section>
                    <h2>Wrap up</h2>
                    <ul>
                        <li><a href="https://github.com/matiwinnetou/reactive-web">https://github.com/matiwinnetou/reactive-web</a></li>
                    </ul>
                    <img src="any_questions.jpg"/>
                </section>

            </div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
                history: true,
				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
//				parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-4.jpg',
//				parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/svg/reveal-svg-fragment.js', condition: function() { return !!document.querySelector( '[data-svg-fragment]' ); } }
				]
			});
		</script>
	</body>
</html>

<!--<section>-->
    <!--<h2>Jargon's Galore - ADT (Algebraic Data Type)</h2>-->
    <!--<blockquote>"ADT is just a data type defined by one or more data constructors, each of which may contain zero or more arguments."</blockquote>-->
    <!--<blockquote>"In computer programming, particularly functional programming and type theory, an algebraic data type is a kind of composite type,-->
        <!--i.e. a type formed by combining other types. Two common classes of algebraic type are product types, i.e. tuples and records, and sum types, also called tagged unions or variant types.[1]"</blockquote>-->
<!--</section>-->

<!--<section>-->
    <!--<h2>Jargon's Galore - Partial Function</h2>-->
    <!--<blockquote>"In FP partial function is a function that is defined only for a few inputs but not all possible ones"</blockquote>-->
<!--</section>-->
